import { Callout } from 'nextra/components'

# React

## 使用函数式组件

使用函数式组件而不是类组件

**✅ Good:**

```js
const MyComponent = () => {
  return <div>My Component</div>
}
```

**❌ Bad:**

```js
class MyComponent extends React.Component {
  render() {
    return <div>My Component</div>
  }
}
```

## 组件作为默认设置导出

将组件作为默认设置导出

**✅ Good:**

```js
export default MyComponent
```

**❌ Bad:**

```js
export { MyComponent }

export default () => {

}
```

<Callout type="default">
使用 `React.lazy` 进行代码拆分仅适用于默认导出的组件。
</Callout>

## 列表中的键

挑选键的最佳方法是使用一个字符串，该字符串可在同级列表中唯一标识列表项。 如果项的顺序可能发生变化，则不建议为键使用索引。 这会对性能产生负面影响，并可能导致组件状态出现问题

**✅ Good:**

```js
array.map((item, index) => <Component key={item.id} {...item}>)
```

**❌ Bad:**

```js
array.map((item, index) => <Component key={index} {...item}>)
```

## useState 函数式更新

如果新状态是通过前一个状态计算出来的，则可以向 setState 传递一个函数。 这样就可以避免状态之间的竞争，并防止可能出现的错误

**✅ Good:**

```js
const [number, setNumber] = useState(1)

return (
  <div>
    <h1>{number}</h1>
    <button onClick={() => setNumber((prevNumber) => prevNumber + 1)}>
      Increase
    </button>
    <button onClick={() => setNumber((prevNumber) => prevNumber - 1)}>
      Decrease
    </button>
  </div>
)
```

**❌ Bad:**

```js
const [number, setNumber] = useState(1)

return (
  <div>
    <h1>{number}</h1>
    <button onClick={() => setNumber(number + 1)}>Increase</button>
    <button onClick={() => setNumber(number - 1）}>Decrease</button>
  </div>
)
```

## useEffect 依赖关系数组 

使用 useEffect 依赖关系数组触发副作用，使代码更简洁

**✅ Good:**

```js
const [page, setPage] = useState(1)

useEffect(() => {
  requestListUser()
  // calls useEffect when page state changes
}, [page])

return (
  <div>
    <button onClick={() => setPage((prevState) => prevState + 1)}>
      Next Page
    </button>
  </div>
)
```

**❌ Bad:**

```js
const [page, setPage] = useState(1)

useEffect(() => {
  requestListUser()
}, [])

const requestListUser = () => {
  setPage((prevState) => prevState + 1)
  // ...
  // any code to return user list
}

return (
  <div>
    <button onClick={() => requestListUser()}>Next Page</button>
  </div>
)
```

## 可读组件 

避免创建非常庞大的组件。 尽可能将其划分为子组件，以便更好地理解和阅读代码

**✅ Good:**

```js
const Screen = () => (
  <Container>
    <Header>
      <Title />
      <Button background="black">Filter</Button>
    </Header>

    <Main>
      <List>
        {data.map((item) => (
          <Card key={item.id} name={item.name} />
        ))}
      </List>
    </Main>
  </Container>
)
```

**❌ Bad:**

```js
const Screen = () => (
  <Box padding={1}>
    <Box alignItems="center">
      <Text>Titulo</Text>
      <Button background="black">Filter</Button>
    </Box>
    <Box marginTop={5}>
      <Box>
        {data.map((item) => (
          <Box key={item.id}>
            <Text color="red">{item.name}</Text>
          </Box>
        ))}
      </Box>
    </Box>
  </Box>
)
```

## 避免直接比较字符串 

当知道所有可能的值时，我们可以使用枚举来实现更好的可读性和控制

**✅ Good:**

```tsx
const FEEDBACK = {
  CORRECT: 'correct',
  INCORRECT: 'incorrect',
}

const MyComponent = (type) => {
  const text = type === FEEDBACK.CORRECT ? '😎' : '😢'
  
  return (
    <Emoji>
      {text}
    </Emoji>
  )
}
```

**❌ Bad:**

```tsx
const MyComponent = (type) => {
  const text = type === 'correct' ? '😎' : '😢'

  return (
    <Emoji>
      {text}
    </Emoji>
  )
}
```

## 使用扩展运算符

在创建组件包装器时，我们可以扩展原始组件的类型。这样封装器就会自动扩展原始组件的所有prop，也可以避免在透传组件增加不必要的类型定义

**✅ Good:**

```tsx
import { MenuItem, TextField } from '@mui/material';
import { TextFieldProps } from '@mui/material';

export type SelectOption = { value: string; label: string };

export type SelectProps = TextFieldProps & {
  options: SelectOption[];
};

const Select = ({ options, ...props }: SelectProps) => {
  return (
    <TextField {...props}>
      {options.map((option) => (
        <MenuItem key={uuidv4()} value={option.value}>
          {option.label}
        </MenuItem>
      ))}
    </TextField>
  );
};
```

**❌ Bad:**

```tsx
import { MenuItem, TextField } from '@mui/material';

export type SelectOption = { value: string; label: string };

export type SelectProps = {
  options: SelectOption[];
  disabled: boolean;
  onChange: () => void;
  value: string;
  onBlur: () => void;
};

const Select = ({
  options,
  disabled,
  onChange,
  value,
  onBlur,
} : SelectProps) => {
  return (
    <TextField
      disabled={disabled}
      onChange={handleOnChange}
      value={value}
      onBlur={handleOnBlur}
    >
      {options.map((option) => (
        <MenuItem key={uuidv4()} value={option.value}>
          {option.label}
        </MenuItem>
      ))}
    </TextField>
  );
};
```

## 条件渲染

### 使用逻辑与运算符

当我们在 JSX 中需要验证一个逻辑条件并返回一个组件时，我们可以直接使用逻辑与运算符

**✅ Good:**

```tsx
import { useState } from 'react'
import Welcome from '../components/Welcome'

const HomePage = () => {
  const [showWelcome, setShowWelcome] = useState(true)
  return showWelcome && <Welcome />
};
```

**❌ Bad:**

```tsx
import { useState } from 'react'
import Welcome from '../components/Welcome'

const HomePage = () => {
  const [showWelcome, setShowWelcome] = useState(true)
  return showWelcome ? <Welcome /> : <></>
};
```
## 使用三元运算符

当我们需要验证两个逻辑情况并返回组件时，我们可以使用三元运算符而不是 if…else

**✅ Good:**

```tsx
import { useState } from 'react'
import Welcome from '../components/Welcome'
import Dashboard from '../components/Dashboard'

const HomePage = () => {
  const [showWelcome, setShowWelcome] = useState(false)
  return showWelcome ? <Welcome /> : <Dashboard />
};
```

**❌ Bad:**

```tsx
import { useState } from 'react'
import Welcome from '../components/Welcome'
import Dashboard from '../components/Dashboard'

const HomePage = () => {
  const [showWelcome, setShowWelcome] = useState(false)

  if (!showWelcome) {
    return <Dashboard />
  }

  return <Welcome />
};
```

## 在 JSX 中布尔属性

在 JSX 中简化传递布尔属性的值

**✅ Good:**

```tsx
<Input type="text" disabled />
```

**❌ Bad:**

```tsx
<Input type="text" disabled={true} />
```

## Props

### 解构 Props

在函数组件的参数括号内解构 props，而不是在函数体内

**✅ Good:**

```tsx
const TodoItem = ({ text, checked }) => (
    <div className="todo">
        <Checkbox className="todo__checkbox" checked={checked} />
        <div>{text}</div>
    </div>
);

const TodoItem = ({ text, checked }) => {
    const { text, checked } = props;
    return (
        <div className="todo">
            <Checkbox className="todo__checkbox" checked={checked} />
            <div>{text}</div>
        </div>
    );
}
```

**❌ Bad:**

```tsx
const TodoItem = (props) => (
    <div className="todo">
        <Checkbox className="todo__checkbox" checked={props.checked} />
        <div>{props.text}</div>
    </div>
);
```

### 避免在属性中使用对象

传递单个属性，而不是将多个属性组合成一个对象来传递。

**✅ Good:**
```tsx
const TodoItem = ({ id, title, text }) => (
    <div className="todo">
        <TodoTitle id={id} title={title} />
        <div>{text}</div>
    </div>
);
```

**❌ Bad:**
```tsx
const TodoItem = ({ todo }) => (
    <div className="todo">
        <TodoTitle id={todo.id} title={todo.title} />
        <div>{todo.text}</div>
    </div>
);
```
